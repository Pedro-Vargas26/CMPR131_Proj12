#pragma once
#ifndef HASHTABLE_H
#define HASHTABLE_H

#include "DynamicArray.h"
#include "Student.h"
#include <type_traits>
#include <concepts>
#include <string>


template <typename U>
concept realNumber = std::is_integral_v<U> || std::is_floating_point_v<U>;

template <typename I>
concept IntegerVal = std::is_integral_v<I>;

template<typename> inline constexpr bool always_false = false;


enum SlotState {
    EMPTY,
    FILLED,
    DELETED
};


template<typename T>
struct Bucket {
    SlotState state;
    T        value;
};



template <typename T>
class HashTable
{
private:
    DynamicArray<Bucket<T>> p_table;
    size_t                  p_capacity;
    size_t                  p_size;
    double                  p_sizeRatio;

    long long hashNumber(realNumber auto num) const {
        return (static_cast<unsigned long long>(num) * 2654435761u) % p_capacity;
    }

    long long hashString(const std::string& key) const {
        unsigned long long hx = 146527;
        for (char c : key)
            hx = (hx * 1315423911u) ^ static_cast<unsigned long long>(c);
        return hx % p_capacity;
    }

    long long hashFunction(const T& obj) const {
        if constexpr (std::is_same_v<T, std::string>)
            return hashString(obj);
        else if constexpr (realNumber<T>)
            return hashNumber(obj);
        else
            static_assert(always_false<T>, "No hash defined for this type");
    }

    void resize() {
        size_t oldCapacity = p_capacity;
        p_capacity += 10;

        DynamicArray<Bucket<T>> old = p_table;  // deep copy
        p_table.clear();

        for (int i = 0; i < static_cast<int>(p_capacity); ++i)
            p_table.append(Bucket<T>{ EMPTY, T{} });

        p_size = 0;

        for (int i = 0; i < static_cast<int>(old.size()); ++i) {
            if (old[i].state == FILLED)
                insert(old[i].value);
        }
    }

    void adjustBuckets() {
        p_sizeRatio = static_cast<double>(p_size) / static_cast<double>(p_capacity);
        if (p_sizeRatio > 0.7)
            resize();
    }

public:
    HashTable(int capacity = 10) {
        if (capacity < 1)
            throw std::runtime_error("Capacity must be positive.");

        p_capacity = static_cast<size_t>(capacity);
        p_size = 0;
        p_sizeRatio = 0.0;

        for (int i = 0; i < capacity; ++i)
            p_table.append(Bucket<T>{ EMPTY, T{} });
    }

    void insert(const T& val) {
        int index = static_cast<int>(hashFunction(val));

        while (p_table[index].state == FILLED) {
            index = (index + 1) % static_cast<int>(p_capacity);
        }

        p_table[index] = Bucket<T>{ FILLED, val };
        ++p_size;

        adjustBuckets();
    }

    int search(const T& val) {
        int index = static_cast<int>(hashFunction(val));

        while (p_table[index].state != EMPTY) {
            if (p_table[index].state == FILLED && p_table[index].value == val)
                return index;

            index = (index + 1) % static_cast<int>(p_capacity);
        }
        return -1;
    }

    int size() const noexcept { return static_cast<int>(p_size); }
    bool empty() const noexcept { return p_size == 0; }

    int remove(const T& val) {
        int index = search(val);
        if (index == -1) return index;

        p_table[index].state = DELETED;
        --p_size;
        return index;
    }

    double getSizeRatio() const { return p_sizeRatio; }

    // Access by bucket index (no bounds checking here; DynamicArray does it)
    T& operator[](int idx) {
        return p_table[idx].value;
    }

    const T& operator[](int idx) const {
        return p_table[idx].value;
    }
};


template <>
class HashTable<Student> {
private:
    DynamicArray<Bucket<Student>> p_table;
    size_t                        p_capacity;
    size_t                        p_size;
    double                        p_sizeRatio;

    long long hashNumber(realNumber auto num) const {
        return (static_cast<unsigned long long>(num) * 2654435761u) % p_capacity;
    }

    long long hashString(const std::string& key) const {
        unsigned long long hx = 146527;
        for (char c : key)
            hx = (hx * 1315423911u) ^ static_cast<unsigned long long>(c);
        return hx % p_capacity;
    }

    template<typename U>
    long long hashFunction(const U& obj) const {
        if constexpr (std::is_same_v<U, std::string>)
            return hashString(obj);
        else if constexpr (realNumber<U>)
            return hashNumber(obj);
        else
            static_assert(always_false<U>, "No hash defined for this type");
    }

    void resize() {
        size_t oldCapacity = p_capacity;
        p_capacity += 10;

        DynamicArray<Bucket<Student>> old = p_table; // deep copy
        p_table.clear();

        for (int i = 0; i < static_cast<int>(p_capacity); ++i)
            p_table.append(Bucket<Student>{ EMPTY, Student() });

        p_size = 0;

        for (int i = 0; i < static_cast<int>(old.size()); ++i) {
            if (old[i].state == FILLED)
                insert(old[i].value);
        }
    }

    void adjustBuckets() {
        p_sizeRatio = static_cast<double>(p_size) / static_cast<double>(p_capacity);
        if (p_sizeRatio > 0.7)
            resize();
    }

public:
    HashTable(int capacity = 10) {
        if (capacity < 1)
            throw std::runtime_error("Capacity must be positive.");

        p_capacity = static_cast<size_t>(capacity);
        p_size = 0;
        p_sizeRatio = 0.0;

        for (int i = 0; i < capacity; ++i)
            p_table.append(Bucket<Student>{ EMPTY, Student() });
    }

    // Insert by full Student object; hash by ID
    void insert(const Student& val) {
        int index = static_cast<int>(hashFunction(val.getID()));

        while (p_table[index].state == FILLED) {
            index = (index + 1) % static_cast<int>(p_capacity);
        }

        p_table[index] = Bucket<Student>{ FILLED, val };
        ++p_size;

        adjustBuckets();
    }

    // Search by ID
    int search(IntegerVal auto ID) {
        int index = static_cast<int>(hashFunction(ID));

        while (p_table[index].state != EMPTY) {
            if (p_table[index].state == FILLED &&
                p_table[index].value.getID() == ID)
                return index;

            index = (index + 1) % static_cast<int>(p_capacity);
        }
        return -1;
    }

    // Search by Student object (compares via operator==)
    int search(const Student& val) {
        int index = static_cast<int>(hashFunction(val.getID()));

        while (p_table[index].state != EMPTY) {
            if (p_table[index].state == FILLED &&
                p_table[index].value == val)
                return index;

            index = (index + 1) % static_cast<int>(p_capacity);
        }
        return -1;
    }

    int size() const noexcept { return static_cast<int>(p_size); }
    bool empty() const noexcept { return p_size == 0; }

    int remove(int sID) {
        int index = search(sID);

        if (index == -1) return index;

        p_table[index].state = DELETED;
        --p_size;
        return index;
    }

    int remove(const Student& val) {
        int index = search(val);
        if (index == -1) return index;

        p_table[index].state = DELETED;
        --p_size;
        return index;
    }

    double getSizeRatio() const { return p_sizeRatio; }

    Student& operator[](int idx) {
        return p_table[idx].value;
    }

    const Student& operator[](int idx) const {
        return p_table[idx].value;
    }
};

#endif 
